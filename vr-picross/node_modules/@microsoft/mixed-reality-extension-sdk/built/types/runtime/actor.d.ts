/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/// <reference types="node" />
import events from 'events';
import { ActorTransform, ActorTransformLike, Appearance, AppearanceLike, Asset, AssetContainer, Attachment, AttachmentLike, AttachPoint, Collider, ColliderLike, ColliderType, CollisionLayer, Light, LightLike, LookAt, LookAtLike, Prefab, RigidBody, RigidBodyLike, Text, TextLike, User } from '.';
import { Animation, Context, CreateAnimationOptions, Guid, LookAtMode, PrimitiveDefinition, ReadonlyMap, SetAnimationStateOptions, SetAudioStateOptions, SetVideoStateOptions, Vector3Like } from '../..';
import { InternalActor } from '../internal/actor';
import { SubscriptionType } from '../network/subscriptionType';
import { Patchable } from '../patchable';
import { ActionHandler, Behavior } from './behaviors';
import { MediaInstance } from './mediaInstance';
/**
 * Describes the properties of an Actor.
 */
export interface ActorLike {
    id: string;
    parentId: string;
    name: string;
    tag: string;
    /**
     * When supplied, this actor will be unsynchronized, and only exist on the client
     * of the User with the given ID. This value can only be set at actor creation.
     * Any actors parented to this actor will also be exclusive to the given user.
     */
    exclusiveToUser: string;
    subscriptions: SubscriptionType[];
    transform: Partial<ActorTransformLike>;
    appearance: Partial<AppearanceLike>;
    light: Partial<LightLike>;
    rigidBody: Partial<RigidBodyLike>;
    collider: Partial<ColliderLike>;
    text: Partial<TextLike>;
    attachment: Partial<AttachmentLike>;
    lookAt: Partial<LookAtLike>;
    grabbable: boolean;
}
/**
 * @hidden
 */
export interface ActorSet {
    [id: string]: Actor;
}
/**
 * An actor represents an object instantiated on the host.
 */
export declare class Actor implements ActorLike, Patchable<ActorLike> {
    private _context;
    private _id;
    private _internal;
    /** @hidden */
    get internal(): InternalActor;
    private _emitter;
    /** @hidden */
    get emitter(): events.EventEmitter;
    private _name;
    private _tag;
    private _exclusiveToUser;
    private _parentId;
    private _subscriptions;
    private _transform;
    private _appearance;
    private _light;
    private _rigidBody;
    private _collider;
    private _text;
    private _attachment;
    private _lookAt;
    private _grabbable;
    private _grab;
    private get grab();
    get context(): Context;
    get id(): string;
    get name(): string;
    get tag(): string;
    set tag(value: string);
    /** @inheritdoc */
    get exclusiveToUser(): string;
    get subscriptions(): SubscriptionType[];
    get transform(): ActorTransform;
    set transform(value: ActorTransform);
    get appearance(): Appearance;
    set appearance(value: Appearance);
    get light(): Light;
    get rigidBody(): RigidBody;
    get collider(): Collider;
    get text(): Text;
    get attachment(): Attachment;
    get lookAt(): LookAt;
    get children(): Actor[];
    get parent(): Actor;
    set parent(value: Actor);
    get parentId(): string;
    set parentId(value: string);
    get grabbable(): boolean;
    set grabbable(value: boolean);
    private constructor();
    /**
     * @hidden
     * TODO - get rid of this.
     */
    static alloc(context: Context, id: string): Actor;
    /**
     * PUBLIC METHODS
     */
    /**
     * Creates a new, empty actor without geometry.
     * @param context The SDK context object.
     * @param options.actor The initial state of the actor.
     */
    static Create(context: Context, options?: {
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * @deprecated
     * Use [[Actor.Create]] instead.
     */
    static CreateEmpty(context: Context, options?: {
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Creates a new actor from a library resource.
     * Host-specific list of library resources. For AltspaceVR, see: https://account.altvr.com/kits
     * @param context The SDK context object.
     * @param options.resourceId The id of the library resource to instantiate.
     * @param options.actor The initial state of the root actor.
     */
    static CreateFromLibrary(context: Context, options: {
        resourceId: string;
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Creates a new actor hierarchy from the provided prefab.
     * @param context The SDK context object.
     * @param options.prefabId The ID of a prefab asset to spawn.
     * @param options.collisionLayer If the prefab contains colliders, put them on this layer.
     * @param options.actor The initial state of the root actor.
     */
    static CreateFromPrefab(context: Context, options: {
        prefabId: string;
        collisionLayer?: CollisionLayer;
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Creates a new actor hierarchy from the provided prefab.
     * @param context The SDK context object.
     * @param options.prefab The prefab asset to spawn.
     * @param options.collisionLayer If the prefab contains colliders, put them on this layer.
     * @param options.actor The initial state of the root actor.
     */
    static CreateFromPrefab(context: Context, options: {
        prefab: Prefab;
        collisionLayer?: CollisionLayer;
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Creates a new actor hierarchy from the provided prefab.
     * @param context The SDK context object.
     * @param options.firstPrefabFrom An asset array containing at least one prefab.
     * @param options.collisionLayer If the prefab contains colliders, put them on this layer.
     * @param options.actor The initial state of the root actor.
     */
    static CreateFromPrefab(context: Context, options: {
        firstPrefabFrom: Asset[];
        collisionLayer?: CollisionLayer;
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Load a glTF model, and spawn the first prefab in the resulting assets. Equivalent
     * to using [[AssetContainer.loadGltf]] and [[Actor.CreateFromPrefab]].
     * @param container The asset container to load the glTF assets into
     * @param options.uri A URI to a .gltf or .glb file
     * @param options.colliderType The type of collider to add to each mesh actor
     * @param options.actor The initial state of the actor
     */
    static CreateFromGltf(container: AssetContainer, options: {
        uri: string;
        colliderType?: 'box' | 'mesh';
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Create an actor with a newly generated mesh. Equivalent to using
     * [[AssetContainer.createPrimitiveMesh]] and adding the result to [[Actor.Create]].
     * @param container The asset container to load the mesh into
     * @param options.definition The primitive shape and size
     * @param options.addCollider Add an auto-typed collider to the actor
     * @param options.actor The initial state of the actor
     */
    static CreatePrimitive(container: AssetContainer, options: {
        definition: PrimitiveDefinition;
        addCollider?: boolean;
        actor?: Partial<ActorLike>;
    }): Actor;
    /**
     * Creates a Promise that will resolve once the actor is created on the host.
     * @returns Promise<void>
     */
    created(): Promise<void>;
    /**
     * Destroys the actor.
     */
    destroy(): void;
    /**
     * Adds a light component to the actor.
     * @param light Light characteristics.
     */
    enableLight(light?: Partial<LightLike>): void;
    /**
     * Adds a rigid body component to the actor.
     * @param rigidBody Rigid body characteristics.
     */
    enableRigidBody(rigidBody?: Partial<RigidBodyLike>): void;
    /**
     * Adds a collider of the given type and parameters on the actor.
     * @param colliderType Type of the collider to enable.
     * @param isTrigger Whether the collider is a trigger volume or not.
     * @param radius The radius of the collider. If omitted, a best-guess radius is chosen
     * based on the size of the currently assigned mesh (loading meshes are not considered).
     * If no mesh is assigned, defaults to 0.5.
     * @param center The center of the collider, or default of the object if none is provided.
     */
    setCollider(colliderType: ColliderType.Sphere, isTrigger: boolean, radius?: number, center?: Vector3Like): void;
    /**
     * Adds a collider of the given type and parameters on the actor.
     * @param colliderType Type of the collider to enable.
     * @param isTrigger Whether the collider is a trigger volume or not.
     * @param size The dimensions of the collider. If omitted, a best-guess size is chosen
     * based on the currently assigned mesh (loading meshes are not considered).
     * If no mesh is assigned, defaults to (1,1,1).
     * @param center The center of the collider, or default of the object if none is provided.
     */
    setCollider(colliderType: ColliderType.Box, isTrigger: boolean, size?: Vector3Like, center?: Vector3Like): void;
    /**
     * Adds a collider of the give type and parameters on the actor.
     * @param colliderType Type of the collider to enable.
     * @param isTrigger Whether the collider is a trigger volume or not.
     * @param size The dimensions of the collider, with the largest component of the vector
     * being the primary axis and height of the capsule (including end caps), and the smallest the diameter.
     * If omitted, a best-guess size is chosen based on the currently assigned mesh
     * (loading meshes are not considered). If no mesh is assigned, defaults to (1, 1, 1).
     * @param center The center of the collider, or default of the object if none is provided.
     */
    setCollider(colliderType: ColliderType.Capsule, isTrigger: boolean, size?: Vector3Like, center?: Vector3Like): void;
    /**
     * Adds a collider whose shape is determined by the current mesh.
     * @param colliderType Type of the collider to enable.
     * @param isTrigger Whether the collider is a trigger volume or not.
     */
    setCollider(colliderType: ColliderType.Auto, isTrigger: boolean): void;
    /**
     * Adds a text component to the actor.
     * @param text Text characteristics
     */
    enableText(text?: Partial<TextLike>): void;
    /**
     * Instruct the actor to face another object, or stop facing an object.
     * @param actorOrActorId The Actor or id of the actor to face.
     * @param lookAtMode (Optional) How to face the target. @see LookUpMode.
     * @param backward (Optional) If true, actor faces away from target rather than toward.
     */
    enableLookAt(actorOrActorId: Actor | string, mode?: LookAtMode, backward?: boolean): void;
    /**
     * Attach to the user at the given attach point.
     * @param userOrUserId The User or id of user to attach to.
     * @param attachPoint Where on the user to attach.
     */
    attach(userOrUserId: User | string, attachPoint: AttachPoint): void;
    /**
     * If attached to a user, detach from it.
     */
    detach(): void;
    /**
     * Subscribe to updates from this actor.
     * @param subscription The type of subscription to add.
     */
    subscribe(subscription: SubscriptionType): void;
    /**
     * Unsubscribe from updates from this actor.
     * @param subscription The type of subscription to remove.
     */
    unsubscribe(subscription: SubscriptionType): void;
    /**
     * Add a grad handler to be called when the given action state has changed.
     * @param grabState The grab state to fire the handler on.
     * @param handler The handler to call when the grab state has changed.
     */
    onGrab(grabState: 'begin' | 'end', handler: ActionHandler): void;
    /**
     * Sets the behavior on this actor.
     * @param behavior The type of behavior to set. Pass null to clear the behavior.
     */
    setBehavior<BehaviorT extends Behavior>(behavior: {
        new (): BehaviorT;
    }): BehaviorT;
    /**
     * Starts playing a preloaded sound.
     * @param soundAssetId Name of sound asset preloaded using AssetManager.
     * @param options Adjustments to pitch and volume, and other characteristics.
     */
    startSound(soundAssetId: string, options: SetAudioStateOptions): MediaInstance;
    /**
     * Starts playing a preloaded video stream.
     * @param videoStreamAssetId Name of video stream asset preloaded using AssetManager.
     * @param options Adjustments to pitch and volume, and other characteristics.
     */
    startVideoStream(videoStreamAssetId: string, options: SetVideoStateOptions): MediaInstance;
    /**
     * Creates an animation on the actor.
     * @param animationName The name of the animation.
     * @param options The animation keyframes, events, and other characteristics.
     * @returns A promise resolving to the resulting animation instance.
     */
    createAnimation(animationName: string, options: CreateAnimationOptions): Promise<Animation>;
    /**
     * @deprecated Set [[Animation.isPlaying]] instead.
     * Enables the animation on the actor. Animation will start playing immediately.
     * @param animationName The name of the animation.
     */
    enableAnimation(animationName: string): void;
    /**
     * @deprecated Set [[Animation.isPlaying]] instead.
     * Disables the animation on the actor. Animation will stop playing immediately.
     * When an animation is disabled, it is also paused (its time does not move forward).
     * @param animationName The name of the animation.
     */
    disableAnimation(animationName: string): void;
    /**
     * @deprecated Set [[Animation.isPlaying]] instead.
     * Starts the animation (sets animation speed to 1).
     * @param animationName The name of the animation.
     */
    resumeAnimation(animationName: string): void;
    /**
     * @deprecated Set [[Animation.isPlaying]] instead.
     * Stops the animation (sets animation speed to zero).
     * @param animationName The name of the animation.
     */
    pauseAnimation(animationName: string): void;
    /**
     * @deprecated Set [[Animation.time]] instead.
     * Sets the animation time (units are in seconds).
     * @param animationName The name of the animation.
     * @param time The desired animation time. A negative value seeks to the end of the animation.
     */
    setAnimationTime(animationName: string, time: number): void;
    /**
     * @deprecated Set properties of an [[Animation]] instance instead.
     * (Advanced) Sets the time, speed, and enabled state of an animation.
     * @param animationName The name of the animation.
     * @param options The time, speed and enabled state to apply. All values are optional. Only the values
     * provided will be applied.
     */
    setAnimationState(animationName: string, state: SetAnimationStateOptions): void;
    /**
     * Animate actor properties to the given value, following the specified animation curve. Actor transform
     * is the only animatable property at the moment. Other properties such as light color may become animatable
     * in the future.
     * @param value The desired final state of the animation.
     * @param duration The length of the interpolation (in seconds).
     * @param curve The cubic-bezier curve parameters. @see AnimationEaseCurves for predefined values.
     */
    animateTo(value: Partial<ActorLike>, duration: number, curve: number[]): void;
    /**
     * Finds child actors matching `name`.
     * @param name The name of the actors to find.
     * @param recurse Whether or not to search recursively.
     */
    findChildrenByName(name: string, recurse: boolean): Actor[];
    /**
     * Actor Events
     */
    /**
     * Set an event handler for the animation-disabled event.
     * @param handler The handler to call when an animation reaches the end or is otherwise disabled.
     */
    onAnimationDisabled(handler: (animationName: string) => any): this;
    /**
     * Set an event handler for the animation-enabled event.
     * @param handler The handler to call when an animation moves from the disabled to enabled state.
     */
    onAnimationEnabled(handler: (animationName: string) => any): this;
    /** The list of animations that target this actor, by ID. */
    get animations(): ReadonlyMap<Guid, Animation>;
    /** The list of animations that target this actor, by name. */
    get animationsByName(): ReadonlyMap<string, Animation>;
    /** Recursively search for the named animation from this actor. */
    findAnimationInChildrenByName(name: string): Animation;
    /** @hidden */
    copy(from: Partial<ActorLike>): this;
    /** @hidden */
    toJSON(): ActorLike;
    /**
     * INTERNAL METHODS
     */
    /**
     * Prepare outgoing messages
     * @hidden
     */
    static sanitize(msg: ActorLike): ActorLike;
    static sanitize(msg: Partial<ActorLike>): Partial<ActorLike>;
    /** @hidden */
    actorChanged: (...path: string[]) => void;
    /**
     * PRIVATE METHODS
     */
    private generateColliderGeometry;
    private _setCollider;
}
//# sourceMappingURL=actor.d.ts.map