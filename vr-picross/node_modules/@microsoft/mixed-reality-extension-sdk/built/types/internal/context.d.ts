/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/// <reference types="node" />
import { ActionEvent, Actor, ActorLike, ActorSet, Animation, AnimationLike, Asset, AssetContainer, BehaviorType, CollisionEvent, CollisionLayer, Context, CreateAnimationOptions, Guid, MediaCommand, PerformanceStats, SetAnimationStateOptions, SetMediaStateOptions, TriggerEvent, UserLike, UserSet } from '../..';
import * as Payloads from '../network/payloads';
import * as Protocols from '../../protocols';
import { ExportedPromise } from '../../utils/exportedPromise';
import { MediaInstance } from '../runtime/mediaInstance';
/**
 * @hidden
 */
export declare class InternalContext {
    context: Context;
    actorSet: ActorSet;
    userSet: UserSet;
    userGroupMapping: {
        [id: string]: number;
    };
    assetContainers: Set<AssetContainer>;
    animationSet: Map<Guid, Animation>;
    protocol: Protocols.Protocol;
    interval: NodeJS.Timer;
    generation: number;
    prevGeneration: number;
    __rpc: any;
    constructor(context: Context);
    Create(options?: {
        actor?: Partial<ActorLike>;
    }): Actor;
    CreateFromLibrary(options: {
        resourceId: string;
        actor?: Partial<ActorLike>;
    }): Actor;
    CreateFromPrefab(options: {
        prefabId: string;
        collisionLayer?: CollisionLayer;
        actor?: Partial<ActorLike>;
    }): Actor;
    private createActorFromPayload;
    CreateFromGltf(container: AssetContainer, options: {
        uri: string;
        colliderType?: 'box' | 'mesh';
        actor?: Partial<ActorLike>;
    }): Actor;
    createAnimation(actorId: string, animationName: string, options: CreateAnimationOptions): Promise<Animation>;
    setAnimationState(actorId: string, animationName: string, state: SetAnimationStateOptions): void;
    setMediaState(mediaInstance: MediaInstance, command: MediaCommand, options?: SetMediaStateOptions, mediaAssetId?: string): void;
    animateTo(actorId: string, value: Partial<ActorLike>, duration: number, curve: number[]): void;
    startListening(): Promise<void>;
    start(): void;
    stop(): void;
    incrementGeneration(): void;
    private assetsIterable;
    update(): void;
    private nextUpdatePromise;
    private resolveNextUpdatePromise;
    /** @hidden */
    nextUpdate(): Promise<void>;
    sendDestroyActors(actorIds: string[]): void;
    updateActors(sactors: Partial<ActorLike> | Array<Partial<ActorLike>>): void;
    updateAnimations(animPatches: Array<Partial<AnimationLike>>): void;
    sendPayload(payload: Payloads.Payload, promise?: ExportedPromise): void;
    receiveRPC(payload: Payloads.EngineToAppRPC): void;
    onClose: () => void;
    userJoined(suser: Partial<UserLike>): void;
    userLeft(userId: string): void;
    updateUser(suser: Partial<UserLike>): void;
    performAction(actionEvent: ActionEvent): void;
    collisionEventRaised(collisionEvent: CollisionEvent): void;
    triggerEventRaised(triggerEvent: TriggerEvent): void;
    setAnimationStateEventRaised(actorId: string, animationName: string, state: SetAnimationStateOptions): void;
    localDestroyActors(actorIds: string[]): void;
    localDestroyActor(actor: Actor): void;
    destroyActor(actorId: string): void;
    sendRigidBodyCommand(actorId: string, payload: Payloads.Payload): void;
    setBehavior(actorId: string, newBehaviorType: BehaviorType): void;
    lookupAsset(id: string): Asset;
    getStats(): PerformanceStats;
}
//# sourceMappingURL=context.d.ts.map