"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v4_1 = __importDefault(require("uuid/v4"));
const __1 = require("../..");
const log_1 = require("../../log");
const execution_1 = require("../../protocols/execution");
const handshake_1 = require("../../protocols/handshake");
const resolveJsonValues_1 = __importDefault(require("../../utils/resolveJsonValues"));
const safeAccessPath_1 = __importDefault(require("../../utils/safeAccessPath"));
const operatingModel_1 = require("../network/operatingModel");
/**
 * @hidden
 */
class InternalContext {
    constructor(context) {
        this.context = context;
        this.actorSet = {};
        this.userSet = {};
        this.userGroupMapping = { default: 1 };
        this.assetContainers = new Set();
        this.animationSet = new Map();
        this.generation = 0;
        this.prevGeneration = 0;
        this.onClose = () => {
            this.stop();
        };
        // Handle connection close events.
        this.onClose = this.onClose.bind(this);
        this.context.conn.on('close', this.onClose);
    }
    Create(options) {
        return this.createActorFromPayload(Object.assign(Object.assign({}, options), { actor: Object.assign(Object.assign({}, (options && options.actor)), { id: v4_1.default() }), type: 'create-empty' }));
    }
    CreateFromLibrary(options) {
        return this.createActorFromPayload(Object.assign(Object.assign({}, options), { actor: Object.assign(Object.assign({}, (options && options.actor)), { id: v4_1.default() }), type: 'create-from-library' }));
    }
    CreateFromPrefab(options) {
        return this.createActorFromPayload(Object.assign(Object.assign({}, options), { actor: Object.assign(Object.assign({}, (options && options.actor)), { id: v4_1.default() }), type: 'create-from-prefab' }));
    }
    createActorFromPayload(payload) {
        // Resolve by-reference values now, ensuring they won't change in the
        // time between now and when this message is actually sent.
        payload.actor = __1.Actor.sanitize(payload.actor);
        // Create the actor locally.
        this.updateActors(payload.actor);
        // Get a reference to the new actor.
        const actor = this.context.actor(payload.actor.id);
        this.protocol.sendPayload(payload, {
            resolve: (replyPayload) => {
                this.protocol.recvPayload(replyPayload);
                let success;
                let message;
                if (replyPayload.type === 'operation-result') {
                    success = replyPayload.resultCode !== 'error';
                    message = replyPayload.message;
                }
                else {
                    success = replyPayload.result.resultCode !== 'error';
                    message = replyPayload.result.message;
                    for (const createdAnimLike of replyPayload.animations) {
                        if (!this.animationSet.has(createdAnimLike.id)) {
                            const createdAnim = new __1.Animation(this.context, createdAnimLike.id);
                            createdAnim.copy(createdAnimLike);
                            this.animationSet.set(createdAnimLike.id, createdAnim);
                        }
                    }
                    for (const createdActorLike of replyPayload.actors) {
                        const createdActor = this.actorSet[createdActorLike.id];
                        if (createdActor) {
                            createdActor.internal.notifyCreated(success, replyPayload.result.message);
                        }
                    }
                }
                if (success) {
                    if (!actor.collider && actor.internal.behavior) {
                        log_1.log.warning('app', 'Behaviors will not function on Unity host apps without adding a'
                            + ' collider to this actor first. Recommend adding a primitive collider'
                            + ' to this actor.');
                    }
                    actor.internal.notifyCreated(true);
                }
                else {
                    actor.internal.notifyCreated(false, message);
                }
            },
            reject: (reason) => {
                actor.internal.notifyCreated(false, reason);
            }
        });
        return actor;
    }
    CreateFromGltf(container, options) {
        // create actor locally
        options.actor = __1.Actor.sanitize(Object.assign(Object.assign({}, options.actor), { id: v4_1.default() }));
        this.updateActors(options.actor);
        const actor = this.context.actor(options.actor.id);
        // reserve actor so the pending actor is ready for commands
        this.protocol.sendPayload({
            type: 'x-reserve-actor',
            actor: options.actor
        });
        // kick off asset loading
        container.loadGltf(options.uri, options.colliderType)
            .then(assets => {
            if (!this.context.actor(actor.id)) {
                // actor was destroyed, stop loading
                return;
            }
            // once assets are done, find first prefab...
            const prefab = assets.find(a => !!a.prefab);
            if (!prefab) {
                actor.internal.notifyCreated(false, `glTF contains no prefabs: ${options.uri}`);
                return;
            }
            // ...and spawn it
            this.createActorFromPayload({
                type: 'create-from-prefab',
                prefabId: prefab.id,
                actor: options.actor
            });
        })
            .catch(reason => actor.internal.notifyCreated(false, reason));
        return actor;
    }
    createAnimation(actorId, animationName, options) {
        var _a, _b, _c;
        const actor = this.actorSet[actorId];
        if (!actor) {
            log_1.log.error('app', `Failed to create animation on ${animationName}. Actor ${actorId} not found.`);
        }
        options = Object.assign({ wrapMode: __1.AnimationWrapMode.Once }, options);
        // Transform animations must be specified in local space
        for (const frame of options.keyframes) {
            if (frame.value.transform && !safeAccessPath_1.default(frame.value, 'transform', 'local')) {
                throw new Error("Transform animations must be specified in local space");
            }
        }
        // generate the anim immediately
        const createdAnim = new __1.Animation(this.context, __1.newGuid());
        createdAnim.copy({
            name: animationName,
            targetActorIds: [actorId],
            weight: ((_a = options.initialState) === null || _a === void 0 ? void 0 : _a.enabled) === true ? 1 : 0,
            speed: (_b = options.initialState) === null || _b === void 0 ? void 0 : _b.speed,
            time: (_c = options.initialState) === null || _c === void 0 ? void 0 : _c.time
        });
        this.animationSet.set(createdAnim.id, createdAnim);
        // Resolve by-reference values now, ensuring they won't change in the
        // time between now and when this message is actually sent.
        options.keyframes = resolveJsonValues_1.default(options.keyframes);
        return new Promise((resolve, reject) => {
            this.protocol.sendPayload(Object.assign({ type: 'create-animation', actorId,
                animationName, animationId: createdAnim.id.toString() }, options), {
                resolve: (reply) => {
                    if (reply.result.resultCode !== 'error') {
                        createdAnim.copy(reply.animations[0]);
                        resolve(createdAnim);
                    }
                    else {
                        reject(reply.result.message);
                    }
                },
                reject
            });
        });
    }
    setAnimationState(actorId, animationName, state) {
        const actor = this.actorSet[actorId];
        if (!actor) {
            log_1.log.error('app', `Failed to set animation state on "${animationName}". Actor "${actorId}" not found.`);
            return;
        }
        const anim = actor.animationsByName.get(animationName);
        if (!anim) {
            log_1.log.error('app', `Failed to set animation state on "${animationName}". ` +
                `No animation with this name was found on actor "${actorId}" (${actor.name}).`);
            return;
        }
        if (state.enabled !== undefined) {
            anim.isPlaying = state.enabled;
        }
        if (state.speed !== undefined) {
            anim.speed = state.speed;
        }
        if (state.time !== undefined) {
            anim.time = state.time;
        }
    }
    setMediaState(mediaInstance, command, options, mediaAssetId) {
        this.protocol.sendPayload({
            type: 'set-media-state',
            id: mediaInstance.id,
            actorId: mediaInstance.actor.id,
            mediaAssetId,
            mediaCommand: command,
            options
        });
    }
    animateTo(actorId, value, duration, curve) {
        const actor = this.actorSet[actorId];
        if (!actor) {
            log_1.log.error('app', `Failed animateTo. Actor ${actorId} not found.`);
        }
        else if (!Array.isArray(curve) || curve.length !== 4) {
            log_1.log.error('app', '`curve` parameter must be an array of four numbers. ' +
                'Try passing one of the predefined curves from `AnimationEaseCurves`');
        }
        else {
            this.protocol.sendPayload({
                type: 'interpolate-actor',
                actorId,
                animationName: v4_1.default(),
                value,
                duration,
                curve,
                enabled: true
            });
        }
    }
    async startListening() {
        try {
            // Startup the handshake protocol.
            const handshake = this.protocol =
                new handshake_1.Handshake(this.context.conn, this.context.sessionId, operatingModel_1.OperatingModel.ServerAuthoritative);
            await handshake.run();
            // Switch to execution protocol.
            const execution = this.protocol = new execution_1.Execution(this.context);
            execution.on('protocol.update-actors', this.updateActors.bind(this));
            execution.on('protocol.destroy-actors', this.localDestroyActors.bind(this));
            execution.on('protocol.user-joined', this.userJoined.bind(this));
            execution.on('protocol.user-left', this.userLeft.bind(this));
            execution.on('protocol.update-user', this.updateUser.bind(this));
            execution.on('protocol.perform-action', this.performAction.bind(this));
            execution.on('protocol.receive-rpc', this.receiveRPC.bind(this));
            execution.on('protocol.collision-event-raised', this.collisionEventRaised.bind(this));
            execution.on('protocol.trigger-event-raised', this.triggerEventRaised.bind(this));
            execution.on('protocol.set-animation-state', this.setAnimationStateEventRaised.bind(this));
            execution.on('protocol.update-animations', this.updateAnimations.bind(this));
            // Startup the execution protocol
            execution.startListening();
        }
        catch (e) {
            log_1.log.error('app', e);
        }
    }
    start() {
        if (!this.interval) {
            this.interval = setInterval(() => this.update(), 0);
            this.context.emitter.emit('started');
        }
    }
    stop() {
        try {
            if (this.interval) {
                this.protocol.stopListening();
                clearInterval(this.interval);
                this.interval = undefined;
                this.context.emitter.emit('stopped');
                this.context.emitter.removeAllListeners();
            }
        }
        catch (_a) { }
    }
    incrementGeneration() {
        this.generation++;
    }
    assetsIterable() {
        return new __1.AssetContainerIterable([...this.assetContainers]);
    }
    update() {
        // Early out if no state changes occurred.
        if (this.generation === this.prevGeneration) {
            return;
        }
        this.prevGeneration = this.generation;
        const syncObjects = [
            ...Object.values(this.actorSet),
            ...this.assetsIterable(),
            ...Object.values(this.userSet),
            ...this.animationSet.values()
        ];
        for (const patchable of syncObjects) {
            const patch = patchable.internal.getPatchAndReset();
            if (!patch) {
                continue;
            }
            if (patchable instanceof __1.Actor) {
                this.protocol.sendPayload({
                    type: 'actor-update',
                    actor: patch
                });
            }
            else if (patchable instanceof __1.Animation) {
                this.protocol.sendPayload({
                    type: 'animation-update',
                    animation: patch
                });
            }
            else if (patchable instanceof __1.Asset) {
                this.protocol.sendPayload({
                    type: 'asset-update',
                    asset: patch
                });
            }
            else if (patchable instanceof __1.User) {
                this.protocol.sendPayload({
                    type: 'user-update',
                    user: patch
                });
            }
        }
        if (this.nextUpdatePromise) {
            this.resolveNextUpdatePromise();
            this.nextUpdatePromise = null;
            this.resolveNextUpdatePromise = null;
        }
    }
    /** @hidden */
    nextUpdate() {
        if (this.nextUpdatePromise) {
            return this.nextUpdatePromise;
        }
        return this.nextUpdatePromise = new Promise(resolve => {
            this.resolveNextUpdatePromise = resolve;
        });
    }
    sendDestroyActors(actorIds) {
        if (actorIds.length) {
            this.protocol.sendPayload({
                type: 'destroy-actors',
                actorIds,
            });
        }
    }
    updateActors(sactors) {
        if (!sactors) {
            return;
        }
        if (!Array.isArray(sactors)) {
            sactors = [sactors];
        }
        const newActorIds = [];
        // Instantiate and store each actor.
        sactors.forEach(sactor => {
            const isNewActor = !this.actorSet[sactor.id];
            const actor = isNewActor ? __1.Actor.alloc(this.context, sactor.id) : this.actorSet[sactor.id];
            this.actorSet[sactor.id] = actor;
            actor.copy(sactor);
            if (isNewActor) {
                newActorIds.push(actor.id);
            }
        });
        newActorIds.forEach(actorId => {
            const actor = this.actorSet[actorId];
            this.context.emitter.emit('actor-created', actor);
        });
    }
    updateAnimations(animPatches) {
        if (!animPatches) {
            return;
        }
        const newAnims = [];
        for (const patch of animPatches) {
            if (this.animationSet.has(patch.id)) {
                continue;
            }
            const newAnim = new __1.Animation(this.context, patch.id);
            this.animationSet.set(newAnim.id, newAnim);
            newAnim.copy(patch);
            newAnims.push(newAnim);
        }
        for (const anim of newAnims) {
            this.context.emitter.emit('animation-created', anim);
        }
    }
    sendPayload(payload, promise) {
        this.protocol.sendPayload(payload, promise);
    }
    receiveRPC(payload) {
        this.context.receiveRPC(payload);
    }
    userJoined(suser) {
        if (!this.userSet[suser.id]) {
            const user = this.userSet[suser.id] = new __1.User(this.context, suser.id);
            user.copy(suser);
            this.context.emitter.emit('user-joined', user);
        }
    }
    userLeft(userId) {
        const user = this.userSet[userId];
        if (user) {
            delete this.userSet[userId];
            this.context.emitter.emit('user-left', user);
        }
    }
    updateUser(suser) {
        const isNewUser = !this.userSet[suser.id];
        const user = isNewUser ? new __1.User(this.context, suser.id) : this.userSet[suser.id];
        user.copy(suser);
        this.userSet[user.id] = user;
        if (isNewUser) {
            this.context.emitter.emit('user-joined', user);
        }
        else {
            this.context.emitter.emit('user-updated', user);
        }
    }
    performAction(actionEvent) {
        if (actionEvent.user) {
            const targetActor = this.actorSet[actionEvent.targetId];
            if (targetActor) {
                targetActor.internal.performAction(actionEvent);
            }
        }
    }
    collisionEventRaised(collisionEvent) {
        const actor = this.actorSet[collisionEvent.colliderOwnerId];
        const otherActor = this.actorSet[(collisionEvent.collisionData.otherActorId)];
        if (actor && otherActor) {
            // Update the collision data to contain the actual other actor.
            collisionEvent.collisionData = Object.assign(Object.assign({}, collisionEvent.collisionData), { otherActor });
            actor.internal.collisionEventRaised(collisionEvent.eventType, collisionEvent.collisionData);
        }
    }
    triggerEventRaised(triggerEvent) {
        const actor = this.actorSet[triggerEvent.colliderOwnerId];
        const otherActor = this.actorSet[triggerEvent.otherColliderOwnerId];
        if (actor && otherActor) {
            actor.internal.triggerEventRaised(triggerEvent.eventType, otherActor);
        }
    }
    setAnimationStateEventRaised(actorId, animationName, state) {
        const actor = this.context.actor(actorId);
        if (actor) {
            actor.internal.setAnimationStateEventRaised(animationName, state);
        }
    }
    localDestroyActors(actorIds) {
        for (const actorId of actorIds) {
            if (this.actorSet[actorId]) {
                this.localDestroyActor(this.actorSet[actorId]);
            }
        }
    }
    localDestroyActor(actor) {
        // Recursively destroy children first
        (actor.children || []).forEach(child => {
            this.localDestroyActor(child);
        });
        // Remove actor from _actors
        delete this.actorSet[actor.id];
        // Raise event
        this.context.emitter.emit('actor-destroyed', actor);
    }
    destroyActor(actorId) {
        const actor = this.actorSet[actorId];
        if (actor) {
            // Tell engine to destroy the actor (will destroy all children too)
            this.sendDestroyActors([actorId]);
            // Clean up the actor locally
            this.localDestroyActor(actor);
        }
    }
    sendRigidBodyCommand(actorId, payload) {
        this.protocol.sendPayload({
            type: 'rigidbody-commands',
            actorId,
            commandPayloads: [payload]
        });
    }
    setBehavior(actorId, newBehaviorType) {
        const actor = this.actorSet[actorId];
        if (actor) {
            this.protocol.sendPayload({
                type: 'set-behavior',
                actorId,
                behaviorType: newBehaviorType || 'none'
            });
        }
    }
    lookupAsset(id) {
        if (id === __1.ZeroGuidString) {
            return null;
        }
        for (const c of this.assetContainers) {
            if (c.assetsById[id]) {
                return c.assetsById[id];
            }
        }
    }
    getStats() {
        const networkStats = this.protocol.conn.statsReport;
        const stats = Object.assign({ actorCount: Object.keys(this.actorSet).length, actorWithMeshCount: 0, prefabCount: 0, materialCount: 0, textureCount: 0, texturePixelsTotal: 0, texturePixelsAverage: 0, meshCount: 0, meshVerticesTotal: 0, meshTrianglesTotal: 0, soundCount: 0, soundSecondsTotal: 0 }, networkStats);
        for (const container of this.assetContainers) {
            stats.prefabCount += container.prefabs.length;
            stats.materialCount += container.materials.length;
            stats.textureCount += container.textures.length;
            stats.meshCount += container.meshes.length;
            stats.soundCount += container.sounds.length;
            for (const tex of container.textures) {
                stats.texturePixelsTotal += (tex.texture.resolution.x || 0) * (tex.texture.resolution.y || 0);
            }
            for (const mesh of container.meshes) {
                stats.meshTrianglesTotal += mesh.mesh.triangleCount || 0;
                stats.meshVerticesTotal += mesh.mesh.vertexCount || 0;
            }
            for (const sound of container.sounds) {
                stats.soundSecondsTotal += sound.sound.duration || 0;
            }
        }
        stats.texturePixelsAverage = stats.texturePixelsTotal / (stats.textureCount || 1);
        for (const actor of Object.values(this.actorSet)) {
            if (actor.appearance.activeAndEnabled && actor.appearance.mesh) {
                stats.actorWithMeshCount += 1;
            }
        }
        return stats;
    }
}
exports.InternalContext = InternalContext;
//# sourceMappingURL=context.js.map