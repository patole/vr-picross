/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { Guid } from '../types/guid';
import { AnimationWrapMode, InternalAnimation } from '.';
import { Patchable } from '../types/patchable';
import { Context } from '../types/runtime';
/** A serialized animation definition */
export interface AnimationLike {
    /** Generated unique ID of this animation */
    id: Guid;
    /** The non-unique name of this animation */
    name: string;
    /** The server time (in milliseconds since the UNIX epoch) when the animation was started */
    basisTime: number;
    /** The current playback time, based on basis time and speed */
    time: number;
    /** Playback speed multiplier */
    speed: number;
    /** When multiple animations play together, this is the relative strength of this instance */
    weight: number;
    /** What happens when the animation hits the last frame */
    wrapMode: AnimationWrapMode;
    /** The IDs of the actors targeted by this animation */
    targetActorIds: Readonly<string[]>;
    /** The length in seconds of the animation */
    duration: number;
}
/** A runtime animation */
export declare class Animation implements AnimationLike, Patchable<AnimationLike> {
    private context;
    /** @hidden */
    internal: InternalAnimation;
    private _id;
    /** @inheritdoc */
    get id(): Guid;
    private _name;
    /** @inheritdoc */
    get name(): string;
    set name(val: string);
    private _basisTime;
    /** @inheritdoc */
    get basisTime(): number;
    set basisTime(val: number);
    private _time;
    /** @inheritdoc */
    get time(): number;
    set time(val: number);
    /** [[time]], correcting for overruns from looping animations. Is always between 0 and [[duration]]. */
    get normalizedTime(): number;
    private _speed;
    /** @inheritdoc */
    get speed(): number;
    set speed(val: number);
    private _weight;
    /** @inheritdoc */
    get weight(): number;
    set weight(val: number);
    private _wrapMode;
    /** @inheritdoc */
    get wrapMode(): AnimationWrapMode;
    set wrapMode(val: AnimationWrapMode);
    private _targetActorIds;
    /** @inheritdoc */
    get targetActorIds(): readonly string[];
    /** The list of actors targeted by this animation. */
    get targetActors(): import("../types/runtime").Actor[];
    private _duration;
    /** @inheritdoc */
    get duration(): number;
    /**
     * Determine if this animation is playing based on the animation's weight. Setting this property calls
     * [[play]] and [[stop]] internally.
     */
    get isPlaying(): boolean;
    set isPlaying(val: boolean);
    /** INTERNAL USE ONLY. Animations are created by loading prefabs with animations on them. */
    constructor(context: Context, id: Guid);
    /**
     * Play the animation by setting its weight to `1`.
     * @param reset If true, restart the animation from the beginning.
     */
    play(reset?: boolean): void;
    /**
     * Halt the running animation by setting its weight to `0`. Has no effect if the animation is already stopped.
     */
    stop(): void;
    private _finished;
    /** @returns A promise that resolves when the animation completes. This only occurs if the wrap mode is set
     * to "Once". The promise is not resolved if the animation is stopped manually.
     */
    finished(): Promise<void>;
    private timeout;
    /** Track the expected completion time of the animation, and flip everything off */
    private updateTimeout;
    /** @hidden */
    toJSON(): AnimationLike;
    /** @hidden */
    copy(patch: Partial<AnimationLike>): this;
    private animationChanged;
}
//# sourceMappingURL=animation.d.ts.map