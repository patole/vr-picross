"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const readPath_1 = __importDefault(require("../utils/readPath"));
/** A runtime animation */
class Animation {
    /** INTERNAL USE ONLY. Animations are created by loading prefabs with animations on them. */
    constructor(context, id) {
        this.context = context;
        /** @hidden */
        this.internal = new _1.InternalAnimation(this);
        this._basisTime = 0;
        this._time = 0;
        this._speed = 0;
        this._weight = 1;
        this._wrapMode = _1.AnimationWrapMode.Once;
        this._targetActorIds = [];
        this._finished = null;
        this._id = id;
    }
    /** @inheritdoc */
    get id() { return this._id; }
    /** @inheritdoc */
    get name() { return this._name; }
    set name(val) {
        this._name = val;
        this.animationChanged('name');
    }
    /** @inheritdoc */
    get basisTime() {
        if (this.isPlaying && this.speed !== 0) {
            return this._basisTime;
        }
        else {
            return Math.max(0, Date.now() - Math.floor(this.time * 1000 / this.speed));
        }
    }
    set basisTime(val) {
        if (this._basisTime !== val) {
            this._basisTime = Math.max(0, val);
            this._time = (Date.now() - this._basisTime) * this.speed / 1000;
            this.animationChanged('basisTime');
            this.animationChanged('time');
            this.updateTimeout();
        }
    }
    /** @inheritdoc */
    get time() {
        if (!this.isPlaying || this.speed === 0) {
            return this._time;
        }
        else {
            return (Date.now() - this.basisTime) * this.speed / 1000;
        }
    }
    set time(val) {
        if (this._time !== val) {
            this._time = val;
            this._basisTime = Math.max(0, Date.now() - Math.floor(this._time * 1000 / this.speed));
            this.animationChanged('time');
            this.animationChanged('basisTime');
            this.updateTimeout();
        }
    }
    /** [[time]], correcting for overruns from looping animations. Is always between 0 and [[duration]]. */
    get normalizedTime() {
        let time = this.time % this.duration;
        if (time < 0) {
            time += this.duration;
        }
        return time;
    }
    /** @inheritdoc */
    get speed() { return this._speed; }
    set speed(val) {
        const curTime = this.time;
        this._speed = val;
        this.animationChanged('speed');
        // recompute stored times such that there is continuity pre- and post-speed change
        if (this.isPlaying && this._speed !== 0) {
            this._basisTime = Math.max(0, Date.now() - Math.floor(curTime * 1000 / this.speed));
            this.animationChanged('basisTime');
        }
        else {
            this._time = curTime;
            this.animationChanged('time');
        }
        this.updateTimeout();
    }
    /** @inheritdoc */
    get weight() { return this._weight; }
    set weight(val) {
        // Getter for time converts the internal _basisTime var into the corresponding offset time,
        // so reassigning it writes this converted time back into the internal _time var.
        // This is needed so the paused state is stored correctly.
        if (val === 0) {
            // eslint-disable-next-line no-self-assign
            this.time = this.time;
        }
        this._weight = val;
        this.animationChanged('weight');
        this.updateTimeout();
    }
    /** @inheritdoc */
    get wrapMode() { return this._wrapMode; }
    set wrapMode(val) {
        this._wrapMode = val;
        this.animationChanged('wrapMode');
        this.updateTimeout();
    }
    /** @inheritdoc */
    get targetActorIds() { return Object.freeze([...this._targetActorIds]); }
    /** The list of actors targeted by this animation. */
    get targetActors() { return this.targetActorIds.map(id => this.context.actor(id)); }
    /** @inheritdoc */
    get duration() { return this._duration; }
    /**
     * Determine if this animation is playing based on the animation's weight. Setting this property calls
     * [[play]] and [[stop]] internally.
     */
    get isPlaying() { return this.weight > 0; }
    set isPlaying(val) {
        if (val) {
            this.play();
        }
        else {
            this.stop();
        }
    }
    /**
     * Play the animation by setting its weight to `1`.
     * @param reset If true, restart the animation from the beginning.
     */
    play(reset = false) {
        // no-op if already playing
        if (this.isPlaying) {
            return;
        }
        // Getter for basis time converts the internal _time var into the corresponding basis time,
        // so reassigning it writes this converted time back into the internal _basisTime var.
        this.basisTime = (reset ? Date.now() : this.basisTime)
            // start slightly in the future so we don't always skip over part of the animation.
            + this.context.conn.quality.latencyMs.value / 1000;
        this.weight = 1;
    }
    /**
     * Halt the running animation by setting its weight to `0`. Has no effect if the animation is already stopped.
     */
    stop() {
        // no-op if already stopped
        if (!this.isPlaying) {
            return;
        }
        this.weight = 0;
    }
    /** @returns A promise that resolves when the animation completes. This only occurs if the wrap mode is set
     * to "Once". The promise is not resolved if the animation is stopped manually.
     */
    finished() {
        if (this._finished) {
            return this._finished.original;
        }
        const promise = new Promise((resolve, reject) => {
            this._finished = { resolve, reject };
        });
        this._finished.original = promise;
        return promise;
    }
    /** Track the expected completion time of the animation, and flip everything off */
    updateTimeout() {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        if (this.wrapMode !== _1.AnimationWrapMode.Once || !this.isPlaying || this.speed === 0) {
            return;
        }
        // if animation is running backward, stop one-shots when it reaches the beginning
        const basisTime = this.basisTime;
        const completionTime = Math.max(basisTime, basisTime + this.duration * 1000 / this.speed);
        this.timeout = setTimeout(() => {
            this.weight = 0;
            if (this._finished) {
                this._finished.resolve();
                this._finished = null;
            }
        }, completionTime - Date.now());
    }
    /** @hidden */
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            basisTime: this.basisTime,
            time: this.time,
            speed: this.speed,
            weight: this.weight,
            wrapMode: this.wrapMode,
            targetActorIds: this.targetActorIds,
            duration: this.duration
        };
    }
    /** @hidden */
    copy(patch) {
        if (!patch) {
            return this;
        }
        this.internal.observing = false;
        if (patch.name !== undefined) {
            this.name = patch.name;
        }
        if (patch.basisTime !== undefined) {
            this.basisTime = patch.basisTime;
        }
        if (patch.speed !== undefined) {
            this.speed = patch.speed;
        }
        if (patch.weight !== undefined) {
            this.weight = patch.weight;
        }
        if (patch.wrapMode) {
            this.wrapMode = patch.wrapMode;
        }
        if (patch.targetActorIds) {
            this._targetActorIds = [...patch.targetActorIds];
        }
        if (patch.duration !== undefined) {
            this._duration = patch.duration;
        }
        this.internal.observing = true;
        return this;
    }
    animationChanged(...path) {
        var _a;
        if (this.internal.observing) {
            this.context.internal.incrementGeneration();
            this.internal.patch = (_a = this.internal.patch, (_a !== null && _a !== void 0 ? _a : {}));
            readPath_1.default(this, this.internal.patch, ...path);
        }
    }
}
exports.Animation = Animation;
//# sourceMappingURL=animation.js.map