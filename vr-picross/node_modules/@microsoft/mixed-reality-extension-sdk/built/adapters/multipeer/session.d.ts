/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/// <reference types="node" />
import { EventEmitter } from 'events';
import { Client, InitializeActorMessage, SyncActor, SyncAnimation, SyncAsset } from '.';
import { Connection, Guid, Message, UserLike } from '../..';
import * as Protocols from '../../protocols';
import * as Payloads from '../../types/network/payloads';
declare type AssetCreationMessage = Message<Payloads.LoadAssets | Payloads.CreateAsset>;
declare type AnimationCreationMessage = Message<Payloads.CreateAnimation | Payloads.CreateActorCommon>;
/**
 * @hidden
 * Class for associating multiple client connections with a single app session.
 */
export declare class Session extends EventEmitter {
    private _conn;
    private _sessionId;
    private _peerAuthoritative;
    private _clientSet;
    private _actorSet;
    private _assetSet;
    private _assetCreatorSet;
    /** Maps animation IDs to animation sync structs */
    private _animationSet;
    /** Maps IDs of messages that can create animations to the messages themselves */
    private _animationCreatorSet;
    private _userSet;
    private _protocol;
    private _disconnect;
    get conn(): Connection;
    get sessionId(): string;
    get protocol(): Protocols.Protocol;
    get clients(): Client[];
    get actors(): Partial<SyncActor>[];
    get assets(): Partial<SyncAsset>[];
    get assetCreators(): Message<Payloads.LoadAssets | Payloads.CreateAsset>[];
    get animationSet(): Map<Guid, Partial<SyncAnimation>>;
    get animations(): IterableIterator<Partial<SyncAnimation>>;
    get animationCreators(): IterableIterator<Message<Payloads.CreateActorCommon | Payloads.CreateAnimation>>;
    get users(): Partial<UserLike>[];
    get actorSet(): {
        [id: string]: Partial<SyncActor>;
    };
    get assetSet(): {
        [id: string]: Partial<SyncAsset>;
    };
    get assetCreatorSet(): {
        [id: string]: Message<Payloads.LoadAssets | Payloads.CreateAsset>;
    };
    get userSet(): {
        [id: string]: Partial<UserLike>;
    };
    get rootActors(): Partial<SyncActor>[];
    get authoritativeClient(): Client;
    get peerAuthoritative(): boolean;
    client: (clientId: string) => Client;
    actor: (actorId: string) => Partial<SyncActor>;
    user: (userId: string) => Partial<UserLike>;
    childrenOf: (parentId: string) => Partial<SyncActor>[];
    creatableChildrenOf: (parentId: string) => Partial<SyncActor>[];
    /**
     * Creates a new Session instance
     */
    constructor(_conn: Connection, _sessionId: string, _peerAuthoritative: boolean);
    /**
     * Performs handshake and sync with the app
     */
    connect(): Promise<void>;
    disconnect(): void;
    /**
     * Adds the client to the session
     */
    join(client: Client): Promise<void>;
    /**
     * Removes the client from the session
     */
    leave(clientId: string): void;
    private setAuthoritativeClient;
    private recvFromClient;
    private recvFromApp;
    preprocessFromApp(message: Message): Message;
    preprocessFromClient(client: Client, message: Message): Message;
    sendToApp(message: Message): void;
    sendToClients(message: Message, filterFn?: (value: Client, index: number) => any): void;
    sendPayloadToClients(payload: Partial<Payloads.Payload>, filterFn?: (value: Client, index: number) => any): void;
    /** @deprecated */
    findAnimation(syncActor: Partial<SyncActor>, animationName: string): import("./syncActor").CreateAnimation;
    /** @deprecated */
    isAnimating(syncActor: Partial<SyncActor>): boolean;
    cacheInitializeActorMessage(message: InitializeActorMessage): void;
    cacheActorUpdateMessage(message: Message<Payloads.ActorUpdate>): void;
    cacheAssetCreationRequest(message: AssetCreationMessage): void;
    cacheAssetCreation(assetId: string, creatorId: string, duration?: number): void;
    cacheAssetUpdate(update: Message<Payloads.AssetUpdate>): void;
    cacheAssetUnload(containerId: string): void;
    cacheAnimationCreationRequest(payload: AnimationCreationMessage): void;
    cacheAnimationCreation(animId: Guid, creatorId: string, duration?: number): void;
    cacheAnimationUpdate(update: Message<Payloads.AnimationUpdate>): void;
}
export {};
//# sourceMappingURL=session.d.ts.map